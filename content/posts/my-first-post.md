---
title: "Netty学习笔记"
date: 2022-11-20T09:03:20-08:00
draft: false
sidebar: "This is the sidebar content for the article."
---
## 一.Netty是什么

### 1.NIO模型的引入

- O模型（阻塞IO）：就像在餐厅取餐时，需要等待食物做好才能取餐，期间你不能离开窗口，需要一直等待询询问窗口是否出餐。
- NIO模型（非阻塞IO）：就像在餐厅取餐时，使用号码排队系统，你可以去做其他事情，而不必一直等待食物做好，当餐台出餐会以系统通知的形式告诉你出餐。

`BIO`模型的明显弊端:

>让我们用一家快递公司的场景来说明BIO:
>
>在这个场景中，你可以把快递公司看作是服务器，每个顾客则是一个客户端连接。当顾客到达快递公司时，他们需要办理寄送快递的手续，而快递公司需要为每个顾客分配一个专门的快递员来处理他们的快递业务。
>
>在BIO模型中，每个客户端连接都需要一个独立的线程来处理，就像快递公司为每个顾客分配了一个专门的快递员。
>
>**线程数量增长问题:**
>
>现在假设有一天，快递公司突然涌入了大量顾客，每个顾客都需要寄送快递。在传统的BIO模型中，为了处理这些顾客，快递公司不得不雇佣更多的快递员（线程），每个顾客（客户端连接）都需要一个独立的快递员（线程）来处理。随着顾客数量的增加，快递公司不得不不断雇佣更多的快递员，导致成本和资源的浪费
>
>**阻塞等待问题**:
>
>而且当一个快递员在处理一个顾客的快递业务时，如果这个顾客提出了一个需要特殊处理或较长时间才能解决的问题，快递员就会一直等待，无法处理其他顾客的快递业务。这就是阻塞等待问题。在这个场景中，你可以把快递公司看作是服务器，每个顾客则是一个客户端连接。当顾客到达快递公司时，他们需要办理寄送快递的手续，而快递公司需要为每个顾客分配一个专门的快递员来处理他们的快递业务。

1. 线程数量增长问题： 在BIO模型中，每个客户端连接都需要一个独立的线程来处理，即使客户端没有实际的IO操作。当有大量客户端连接时，就会创建大量线程，这会占用大量系统资源，而且线程切换也会带来额外的开销。这种线程数量增长问题称为"线程爆炸"。
2. 阻塞等待问题： 在BIO模型中，当一个线程在执行IO操作时，它会一直阻塞等待，直到IO操作完成或超时。这导致线程在等待IO时无法被释放出来，从而无法处理其他客户端连接。如果IO操作耗时较长，就会导致大量线程被阻塞，造成资源浪费和性能下降。

> 在NIO模型中，快递公司可以引入一个号码排队系统，让顾客自行取号，然后在大屏幕上显示当前叫号的号码。在这里，快递公司可以将号码排队系统看作是选择器（Selector），大屏幕上显示的号码就是已就绪的通道（快递员）。
>
> 1. 启动：
>
> - 快递公司（服务器）打开营业窗口，创建一个选择器（Selector）来管理客户端连接。
> - 快递公司（服务器）启动多个快递员线程（Reactor线程），这些快递员线程会不断轮询选择器，处理就绪的通道（已取号的顾客）。
>
> 1. 顾客（客户端）到达：
>
> - 当有顾客（客户端）到达快递公司（服务器），他们先取一个号码（注册到选择器），然后可以自由活动，不需要一直等待。
> - 快递公司的大屏幕（选择器）会显示当前叫号的号码（已就绪的通道）。
>
> 1. 快递员处理：
>
> - 每个快递员线程会不断地从选择器中获取已就绪的通道（已取号的顾客）。
> - 当一个通道（快递员）处于就绪状态（有客户需要处理）时，快递员线程会立即处理该通道的（已取号的顾客）快递业务，这可能包括读取快递信息、写入快递信息等。
>
> 1. 快递员轮询选择器：
>
> - 当一个快递员处理完一个通道的业务后，会立即返回选择器，查看是否有其他通道已经就绪。
> - 如果有其他通道已就绪，则立即处理该通道的业务，如果没有就绪的通道，则快递员线程会在选择器上阻塞，等待新的通道就绪，以避免空闲等待。

通过使用NIO模型，快递公司可以高效地利用每个快递员的时间，避免了快递员一直等待，提高了服务效率。类似地，在NIO模型中，服务器通过一个线程处理多个客户端连接的IO操作，避免了线程数量增长和阻塞等待问题，提高了并发性能和响应能力。

总结：在NIO模型中，快递公司通过号码排队系统和快递员的智能调度，提高了服务效率，减少了资源浪费，类似地，在NIO模型中，服务器通过选择器和快递员线程的智能调度，提高了并发性能，充分利用系统资源。



## 二.启动Netty服务端

```java
public class Server {
    public static void main(String[] args) {
        /**
         * 三部曲:线程模型 io模型 读写处理逻辑
         */
        ServerBootstrap serverBootstrap = new ServerBootstrap();
        // ========= 第一步:线程模型 ====================
        // 负责处理新连接的线程组:类似老板，不做事，只负责接活
        NioEventLoopGroup boss = new NioEventLoopGroup();
        // 负责数据读写的线程组:类似员工，当老板接活后，交给员工去做
        NioEventLoopGroup works = new NioEventLoopGroup();

        // 服务端启动引导类配置
        serverBootstrap.group(boss,works)
        // ======  第二步:IO模型  ====================
                // 指定IO模型为NIO
                .channel(NioServerSocketChannel.class)
        // ======  第三步:读写处理逻辑  ================
                // 定义每个连接的数据读写
                .childHandler(new ChannelInitializer<NioSocketChannel>() {
                    @Override
                    protected void initChannel(NioSocketChannel channel) throws Exception {
                        // 服务端接收到数据后，需要解码
                        channel.pipeline().addLast(new StringDecoder());
                        // 服务端接收到数据后，需要处理，这里用一个简单的打印
                        channel.pipeline().addLast(new SimpleChannelInboundHandler<String>() {
                            @Override
                            protected void channelRead0(ChannelHandlerContext channelHandlerContext, String s) throws Exception {
                                System.out.println("【服务端收到消息】"+s);
                            }
                        });

                    }
                }).bind(9000);

    }
}
```

